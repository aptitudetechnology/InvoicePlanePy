#generated by gemini - please check it with claude

from fastapi import FastAPI, Request, Form
from fastapi.responses import HTMLResponse
from fastapi.templating import Jinja2Templates
from typing import List, Dict, Any

app = FastAPI()

# Configure Jinja2Templates to point to your templates directory
# Assuming your templates are in a folder named 'templates' at the root of your project
templates = Jinja2Templates(directory="templates")

# In a real application, this data would come from a database
# For demonstration, we'll use a simple in-memory list
tax_rates_db: List[Dict[str, Any]] = [
    {"id": 1, "name": "VAT", "rate": 20.00, "isDefault": True, "isActive": True},
    {"id": 2, "name": "Sales Tax", "rate": 8.25, "isDefault": False, "isActive": True},
    {"id": 3, "name": "GST", "rate": 10.00, "isDefault": False, "isActive": False}
]
next_id = 4 # Simple way to manage IDs for new entries

@app.get("/tax-rates", response_class=HTMLResponse)
async def read_tax_rates(request: Request):
    """
    Renders the tax rates management page.
    """
    return templates.TemplateResponse(
        "tax_rates.html",
        {"request": request, "tax_rates": tax_rates_db}
    )

# In a real application, you'd have API endpoints for adding, editing, and deleting
# For example, a POST endpoint to handle the form submission from the modal:
# (This is a simplified example; actual implementation would involve Pydantic models for validation)
@app.post("/tax-rates/save")
async def save_tax_rate(
    request: Request,
    tax_id: int = Form(None), # Will be None for new rates
    tax_name: str = Form(...),
    tax_rate: float = Form(...),
    is_default: bool = Form(False),
    is_active: bool = Form(False)
):
    """
    Handles saving (adding or updating) a tax rate.
    Note: This is a simplified example. In a real app, you'd typically use
    a more robust API design (e.g., separate PUT for update, POST for create)
    and proper data validation with Pydantic models.
    """
    global next_id # Needed to modify the global next_id counter

    if is_default:
        # Ensure only one default tax rate
        for rate in tax_rates_db:
            rate["isDefault"] = False

    if tax_id is None: # Adding a new tax rate
        new_tax_rate = {
            "id": next_id,
            "name": tax_name,
            "rate": tax_rate,
            "isDefault": is_default,
            "isActive": is_active
        }
        tax_rates_db.append(new_tax_rate)
        next_id += 1
    else: # Editing an existing tax rate
        for i, rate in enumerate(tax_rates_db):
            if rate["id"] == tax_id:
                tax_rates_db[i] = {
                    "id": tax_id,
                    "name": tax_name,
                    "rate": tax_rate,
                    "isDefault": is_default,
                    "isActive": is_active
                }
                break
    
    # In a real scenario, you'd likely redirect or return a success message
    # For now, we'll re-render the page to show the changes
    return templates.TemplateResponse(
        "tax_rates.html",
        {"request": request, "tax_rates": tax_rates_db}
    )


# You'd also need endpoints for deleting, etc.
# For example:
@app.delete("/tax-rates/{tax_id}")
async def delete_tax_rate_api(tax_id: int):
    """
    Deletes a tax rate (API endpoint, not directly linked to the current JS `deleteTaxRate` function
    which does client-side filtering).
    """
    global tax_rates_db
    initial_len = len(tax_rates_db)
    tax_rates_db = [rate for rate in tax_rates_db if rate["id"] != tax_id]
    if len(tax_rates_db) < initial_len:
        return {"message": f"Tax rate {tax_id} deleted successfully."}
    return {"message": f"Tax rate {tax_id} not found."}, 404

# To run this example:
# 1. Save the Jinja2 template as `templates/tax_rates.html`
# 2. Save this Python code as `main.py`
# 3. Run from your terminal: `uvicorn main:app --reload`
# 4. Open your browser to `http://127.0.0.1:8000/tax-rates`